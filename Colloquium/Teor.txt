1. Что такое ООП?
ООП это определённый подход/методология в программировании, который позволяет манипулировать объектами как это происходит в реальном мире. Вне зависимости от типа этих объектов и даже необязательно зная, какие манипуляции над этим объектом будут проводиться, в том числе как происходит взаимодействие между объектами. Так называемые "Три основных принципа ООП": 1. Message Passing 2. Late Binding 3. IoC. Реализация же подразумевает использование принципов инкапсуляции, наследования и полиморфизма.  

2. ООДекомпозиция
Это разделение задачи на более простые составные части. Обычно разбиение строится иерархически: система программы делится на большие модули, которые затем разбиваются на подмодули. Декомпозиция зависит от задачи и проводится логически: отдельные модули (подзадачи) для входа-выхода, отдельные для каждой отдельной функции, которая выполняется, и её данных. Таким образом формируется система, взаимодействие частей которой минимально. Важно, чтобы выделенный модуль был цельным и автономным.

3. Дизайн ПО
Работа по организации кода и интерфейса, их проектирование, в том числе и планирование "внешней оболочки" ПО. То есть определение того, как будут работать компоненты, как пользователь будет взаимодействовать с приложением, как будет реализован внешний дизайн, а так же разработка единого стандарта для дальнейшей работы над ПО. Например: разработка UI, дизайн любого веб-сайта, создание дизайн-документации. 

4. Магическое число 7 Миллера в контексте АйТи (7 примеров)
Человек обрабатывает не более 7(+-2) объектов информации одновременно. Суть в том, чтобы при разработке UX/UI делить информацию на небольшое количество блоков. Особенно если человек работает с большим объёмом информации. В любом меню не должно быть слишком пунктов, у функций - не более 7+2 параметров, не более 7+2 полей класса, не более 7+2 графиков в одном окне, не более 7+2 сообщений об ошибках, не более 7+2 опций, не более 7+2 флагов, Однако это не является правилом. 

5. 5 признаков сложных систем по Гради Бучу (3 примера)
Из книги: 
1. "Сложные системы часто являются иерархическими и состоят из взаимозависимых подсистем, которые в свою очередь также могут быть разделены на подсистемы, и т.д., вплоть до самого низкого уровням."
2. Выбор, какие компоненты в данной системе считаются элементарными, относительно произволен и в большой степени оставляется на усмотрение исследователя.
3. "Внутрикомпонентная связь обычно сильнее, чем связь между компонентами. Это обстоятельство позволяет отделять "высокочастотные" взаимодействия внутри компонентов от "низкочастотной" динамики взаимодействия между компонентами
4. "Иерархические системы обычно состоят из немногих типов подсистем, по-разному скомбинированных и организованных"
5. "Любая работающая сложная система является результатом развития работавшей более простой системы... Сложная система, спроектированная "с нуля", никогда не заработает. Следует начинать с работающей простой системы".

Пример 1: Социальная сеть
Иерархия: Платформа -> Сервис новостей, Мессенджер, Система рекламы -> В сервисе новостей: алгоритм ранжирования, база постов, модерация.
Первичность элементов: Тренды и виральный контент возникают сами из взаимодействий миллионов пользователей, а не назначаются администрацией.
Разделение по интересам: Команда backend-разработки, команда data science, команда UX/UI, команда монетизации.
Механизмы, а не результаты: Алгоритм ленты — это не список постов, а механизм отбора и ранжирования, который динамически подстраивается под поведение каждого пользователя.
Эволюция: Соцсеть постоянно меняет дизайн, добавляет функции (сторис, риels), адаптирует алгоритмы под новые законы и поведение пользователей.

Пример 2: Интернет-банкинг
1. Иерархическая структура
Уровень 0: Приложение интернет-банка.
Уровень 1: Фронтенд (веб-интерфейс, мобильное приложение), Бэкенд (основная логика), База данных (информация о клиентах, счетах, транзакциях).
Уровень 2: Бэкенд состоит из микросервисов.
Уровень 3: Каждый микросервис сам состоит из компонентов: контроллеры, сервис-слой, репозитории для работы с БД, клиенты для общения с другими сервисами (например, с внешними платежными системами).
2. Относительная первичность элементов (Эмерджентное поведение)
Выявление мошеннических схем: Система безопасности банка не знает все возможные схемы мошенничества заранее. Она анализирует миллионы событий в реальном времени: необычная геолокация входа, странная сумма перевода, подозрительная последовательность действий. Паттерн мошенничества проявляется (emerges) как результат анализа этих разрозненных данных множеством алгоритмов, а не потому что некий "главный сервер" заранее знает о конкретной атаке. Нагрузка на систему: В час пик (например, утром в понедельник) нагрузка возникает не по команде, а как результат совокупных действий тысяч пользователей, которые одновременно решили проверить баланс или сделать перевод. Система реагирует на это эмерджентное поведение масштабированием.
3. Разделение на подсистемы по интересам
Над банком работают совершенно разные команды, каждая со своей "моделью":
Команда безопасности: "Интерес" — защита данных, предотвращение мошенничества, соответствие стандартам (PCI DSS). Их модель — потоки данных, угрозы, уязвимости.
Команда платежного ядра: "Интерес" — гарантированное проведение транзакции, атомарность операций (списание/зачисление), работа с ЦБ (система быстрых платежей). Их модель — транзакции, ACID-свойства.
Команда UX/UI: "Интерес" — удобство интерфейса, простота перевода денег, скорость отклика. Их модель — пользовательские сценарии, кликстримы, A/B тесты.
Команда аналитики: "Интерес" — анализ финансового поведения клиентов для создания новых продуктов. Их модель — данные для ML-моделей.
4. Наличие механизмов, а не результатов
Скоринг и выдача кредитов: Банк не прописывает в коде правила для каждого человека. Вместо этого он создает механизм — скоринговую модель на основе ML. Эта модель сама, анализируя сотни параметров (доход, кредитная история, поведение в приложении), выдает вероятность дефолта. Механизм универсален и может оценить любого нового клиента.
5. Постоянное развитие и эволюция
Интернет-банк 10 лет назад — это простой веб-сайт для просмотра баланса и перевода между счетами.
Сегодня это экосистема: в него интегрированы инвестиции, страхование, кредиты, умные подписки, cashback-сервисы, чат-боты поддержки.
Система постоянно эволюционирует: добавляются новые платежные шлюзы, обновляются алгоритмы безопасности, полностью меняется дизайн, появляется поддержка биометрии и Open Banking API. Она никогда не бывает "законченной".

Пример 3: GitHub
1. Иерархическая структура
Уровень 0: Платформа GitHub.
Уровень 1: Frontend (веб-интерфейс), Backend API, Git-сервер (обработка репозиториев), Базы данных (пользователи, репозитории, Issues, Pull Requests).
Уровень 2: Backend состоит из сервисов.
Уровень 3: Сервис GitHub Actions состоит из подсистем: планировщик задач (scheduler), раннеры (runners), кеш зависимостей.
2. Относительная первичность элементов (Эмерджентное поведение)
Формирование трендов и популярности репозиториев: Репозиторий не становится "популярным" по команде администрации GitHub. Его популярность проявляется как результат тысяч независимых действий пользователей: звездочки (stars), форки (forks), упоминания в Issues и обсуждениях. Алгоритм "Trending repositories" выявляет эти эмерджентные паттерны.
Сообщество вокруг проекта: Правила и культура взаимодействия в рамках крупного Open-Source проекта (например, kubernetes/kubernetes) не прописаны сверху. Они emerge из миллионов взаимодействий между мейнтейнерами, контрибьюторами и пользователями через Issues и Pull Requests.
3. Разделение на подсистемы по интересам
Команда Git-инфраструктуры: "Интерес" — скорость работы git push/pull, надежность хранения данных, распределенные файловые системы.
Команда Collaboration Tools: "Интерес" — удобство интерфейса Pull Request'а, система ревью кода, интерактивные конфликты слияния.
Команда GitHub Actions: "Интерес" — производительность и изоляция раннеров, безопасность workflows, доступность тысяч готовых экшенов.
Команда безопасности: "Интерес" — сканирование секретов в коде (Dependabot), предупреждения об уязвимостях, управление доступом.
4. Наличие механизмов, а не результатов
GitHub Actions: Это не набор готовых скриптов для сборки конкретных проектов. Это механизм (платформа), который позволяет описать workflow в YAML-файле. Пользователи сами создают бесконечное количество сценариев (сборка, деплой, тестирование, модерация) на основе этого универсального механизма.
Protected Branches и правила для Pull Requests: Администратор репозитория не проверяет каждый PR вручную. Он настраивает механизм (ruleset): "мерж в ветку main возможен только после успешного прохождения CI/CD и обязательного апрува от 2 ревьюверов". Система автоматически применяет эти правила ко всем PR, независимо от их содержания.
5. Постоянное развитие и эволюция
Ранний GitHub (2008 г.): Фактически веб-просмотрщик для Git-репозиториев с базовыми Issues.
GitHub сегодня: Это платформа для DevOps: Появились Pull Requests с интерактивным ревью. Добавлены Projects (канбан-доски). Внедрен AI-помощник GitHub Copilot. Появились Codespaces (разработка в облаке).
Платформа постоянно эволюционирует, реагируя на потребности разработчиков и меняющиеся практики (от просто Git к полному DevOps-циклу).